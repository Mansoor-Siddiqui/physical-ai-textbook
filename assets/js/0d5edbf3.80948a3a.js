"use strict";(globalThis.webpackChunkphysical_ai_textbook=globalThis.webpackChunkphysical_ai_textbook||[]).push([[322],{832(n,e,r){r.r(e),r.d(e,{assets:()=>d,contentTitle:()=>l,default:()=>p,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"humanoid/index","title":"Humanoid Robotics","description":"Design principles and control systems for humanoid robots","source":"@site/docs/humanoid/index.md","sourceDirName":"humanoid","slug":"/humanoid/","permalink":"/physical-ai-textbook/docs/humanoid/","draft":false,"unlisted":false,"editUrl":"https://github.com/Mansoor-Siddiqui/physical-ai-textbook/tree/master/physical-ai-textbook/docs/humanoid/index.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6,"title":"Humanoid Robotics","description":"Design principles and control systems for humanoid robots","keywords":["humanoid","bipedal","locomotion","manipulation","balance","control"]},"sidebar":"textbookSidebar","previous":{"title":"Vision-Language-Action Models","permalink":"/physical-ai-textbook/docs/vla-models/"},"next":{"title":"Resources & References","permalink":"/physical-ai-textbook/docs/resources/"}}');var t=r(4848),o=r(8453),s=r(5168);const a={sidebar_position:6,title:"Humanoid Robotics",description:"Design principles and control systems for humanoid robots",keywords:["humanoid","bipedal","locomotion","manipulation","balance","control"]},l="Humanoid Robotics",d={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Why Humanoid Robots?",id:"why-humanoid-robots",level:2},{value:"The Humanoid Landscape",id:"the-humanoid-landscape",level:3},{value:"Humanoid Anatomy",id:"humanoid-anatomy",level:2},{value:"Degrees of Freedom",id:"degrees-of-freedom",level:3},{value:"Kinematic Structure",id:"kinematic-structure",level:3},{value:"Bipedal Locomotion",id:"bipedal-locomotion",level:2},{value:"The Walking Problem",id:"the-walking-problem",level:3},{value:"Zero Moment Point (ZMP)",id:"zero-moment-point-zmp",level:3},{value:"Linear Inverted Pendulum Model (LIPM)",id:"linear-inverted-pendulum-model-lipm",level:3},{value:"Whole-Body Control",id:"whole-body-control",level:3},{value:"Manipulation",id:"manipulation",level:2},{value:"Humanoid Hands",id:"humanoid-hands",level:3},{value:"Coordinated Manipulation",id:"coordinated-manipulation",level:3},{value:"Reinforcement Learning for Humanoids",id:"reinforcement-learning-for-humanoids",level:2},{value:"Future of Humanoids",id:"future-of-humanoids",level:2},{value:"Emerging Capabilities",id:"emerging-capabilities",level:3},{value:"Challenges Ahead",id:"challenges-ahead",level:3},{value:"Summary",id:"summary",level:2}];function h(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"humanoid-robotics",children:"Humanoid Robotics"})}),"\n",(0,t.jsxs)("div",{className:"learning-objectives",children:[(0,t.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),(0,t.jsx)(e.p,{children:"By the end of this chapter, you will be able to:"}),(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Understand the design principles of humanoid robots"}),"\n",(0,t.jsx)(e.li,{children:"Explain bipedal locomotion and balance control"}),"\n",(0,t.jsx)(e.li,{children:"Implement basic humanoid control strategies"}),"\n",(0,t.jsx)(e.li,{children:"Understand manipulation and grasping for human-like hands"}),"\n",(0,t.jsx)(e.li,{children:"Recognize the challenges and future of humanoid robotics"}),"\n"]})]}),"\n",(0,t.jsx)(e.h2,{id:"why-humanoid-robots",children:"Why Humanoid Robots?"}),"\n",(0,t.jsx)(e.p,{children:"Humanoid robots are designed to operate in environments built for humans. Their human-like form factor enables them to:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Navigate human spaces"}),": Stairs, doors, furniture"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Use human tools"}),": Objects designed for human hands"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Interact naturally"}),": Familiar form for human-robot interaction"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Perform human tasks"}),": Work designed for human bodies"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"the-humanoid-landscape",children:"The Humanoid Landscape"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502                    HUMANOID ROBOT PLATFORMS                      \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502                                                                  \u2502\r\n\u2502   Research Platforms          Commercial Platforms               \u2502\r\n\u2502   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510           \u2502\r\n\u2502   \u2502 ASIMO (Honda)   \u2502         \u2502 Atlas (Boston Dyn.) \u2502           \u2502\r\n\u2502   \u2502 WALK-MAN (IIT)  \u2502         \u2502 Digit (Agility)     \u2502           \u2502\r\n\u2502   \u2502 Valkyrie (NASA) \u2502         \u2502 Figure 01/02        \u2502           \u2502\r\n\u2502   \u2502 Talos (PAL)     \u2502         \u2502 Optimus (Tesla)     \u2502           \u2502\r\n\u2502   \u2502 TORO (DLR)      \u2502         \u2502 Phoenix (Sanctuary) \u2502           \u2502\r\n\u2502   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518         \u2502 NEO (1X)            \u2502           \u2502\r\n\u2502                               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518           \u2502\r\n\u2502                                                                  \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,t.jsx)(e.h2,{id:"humanoid-anatomy",children:"Humanoid Anatomy"}),"\n",(0,t.jsx)(e.h3,{id:"degrees-of-freedom",children:"Degrees of Freedom"}),"\n",(0,t.jsx)(e.p,{children:"A typical humanoid has 30-50+ degrees of freedom (DOF):"}),"\n",(0,t.jsxs)(e.table,{children:[(0,t.jsx)(e.thead,{children:(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.th,{children:"Body Part"}),(0,t.jsx)(e.th,{children:"Typical DOF"}),(0,t.jsx)(e.th,{children:"Function"})]})}),(0,t.jsxs)(e.tbody,{children:[(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:(0,t.jsx)(e.strong,{children:"Head/Neck"})}),(0,t.jsx)(e.td,{children:"2-3"}),(0,t.jsx)(e.td,{children:"Gaze direction, perception"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:(0,t.jsx)(e.strong,{children:"Torso/Spine"})}),(0,t.jsx)(e.td,{children:"3-6"}),(0,t.jsx)(e.td,{children:"Posture, weight transfer"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:(0,t.jsx)(e.strong,{children:"Shoulder"})}),(0,t.jsx)(e.td,{children:"3"}),(0,t.jsx)(e.td,{children:"Arm positioning"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:(0,t.jsx)(e.strong,{children:"Elbow"})}),(0,t.jsx)(e.td,{children:"1-2"}),(0,t.jsx)(e.td,{children:"Arm extension"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:(0,t.jsx)(e.strong,{children:"Wrist"})}),(0,t.jsx)(e.td,{children:"2-3"}),(0,t.jsx)(e.td,{children:"Hand orientation"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:(0,t.jsx)(e.strong,{children:"Hand"})}),(0,t.jsx)(e.td,{children:"10-20"}),(0,t.jsx)(e.td,{children:"Manipulation, grasping"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:(0,t.jsx)(e.strong,{children:"Hip"})}),(0,t.jsx)(e.td,{children:"3"}),(0,t.jsx)(e.td,{children:"Leg positioning"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:(0,t.jsx)(e.strong,{children:"Knee"})}),(0,t.jsx)(e.td,{children:"1"}),(0,t.jsx)(e.td,{children:"Leg extension"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:(0,t.jsx)(e.strong,{children:"Ankle"})}),(0,t.jsx)(e.td,{children:"2-3"}),(0,t.jsx)(e.td,{children:"Balance, foot placement"})]})]})]}),"\n",(0,t.jsx)(e.h3,{id:"kinematic-structure",children:"Kinematic Structure"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:"import numpy as np\r\nfrom scipy.spatial.transform import Rotation\r\n\r\nclass HumanoidKinematics:\r\n    \"\"\"Simplified humanoid kinematic chain\"\"\"\r\n    \r\n    def __init__(self):\r\n        # Define link lengths (in meters)\r\n        self.links = {\r\n            'torso': 0.4,\r\n            'upper_arm': 0.3,\r\n            'lower_arm': 0.25,\r\n            'upper_leg': 0.4,\r\n            'lower_leg': 0.4,\r\n            'foot': 0.1\r\n        }\r\n        \r\n        # Joint limits (in radians)\r\n        self.joint_limits = {\r\n            'hip_pitch': (-1.5, 1.5),\r\n            'hip_roll': (-0.5, 0.5),\r\n            'hip_yaw': (-0.8, 0.8),\r\n            'knee': (0.0, 2.5),\r\n            'ankle_pitch': (-0.8, 0.8),\r\n            'ankle_roll': (-0.4, 0.4),\r\n        }\r\n    \r\n    def forward_kinematics(self, joint_angles: dict) -> dict:\r\n        \"\"\"Compute end-effector positions from joint angles\"\"\"\r\n        positions = {}\r\n        \r\n        # Start from pelvis (base frame)\r\n        T_pelvis = np.eye(4)\r\n        \r\n        # Right leg chain\r\n        T_hip = self._joint_transform(\r\n            joint_angles['r_hip_pitch'],\r\n            joint_angles['r_hip_roll'],\r\n            joint_angles['r_hip_yaw']\r\n        )\r\n        \r\n        T_knee = self._joint_transform(joint_angles['r_knee'], 0, 0)\r\n        T_ankle = self._joint_transform(\r\n            joint_angles['r_ankle_pitch'],\r\n            joint_angles['r_ankle_roll'],\r\n            0\r\n        )\r\n        \r\n        # Chain transforms\r\n        T_right_foot = T_pelvis @ T_hip @ T_knee @ T_ankle\r\n        positions['right_foot'] = T_right_foot[:3, 3]\r\n        \r\n        # Similar for left leg, arms, etc.\r\n        return positions\r\n    \r\n    def _joint_transform(self, pitch, roll, yaw):\r\n        \"\"\"Create transformation matrix from joint angles\"\"\"\r\n        R = Rotation.from_euler('xyz', [roll, pitch, yaw]).as_matrix()\r\n        T = np.eye(4)\r\n        T[:3, :3] = R\r\n        return T\n"})}),"\n",(0,t.jsx)(e.h2,{id:"bipedal-locomotion",children:"Bipedal Locomotion"}),"\n",(0,t.jsx)(e.h3,{id:"the-walking-problem",children:"The Walking Problem"}),"\n",(0,t.jsx)(e.p,{children:"Walking is a dynamically unstable process. Unlike wheeled robots, bipeds must actively maintain balance while moving."}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502                    WALKING GAIT CYCLE                           \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502                                                                 \u2502\r\n\u2502   Double Support    Single Support    Double Support            \u2502\r\n\u2502   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510          \u2502\r\n\u2502   \u2502   \u2588\u2588  \u2588\u2588    \u2502   \u2502   \u2588\u2588        \u2502   \u2502   \u2588\u2588  \u2588\u2588    \u2502          \u2502\r\n\u2502   \u2502   \u25bc\u25bc  \u25bc\u25bc    \u2502   \u2502   \u25bc\u25bc        \u2502   \u2502   \u25bc\u25bc  \u25bc\u25bc    \u2502          \u2502\r\n\u2502   \u2502  \u2550\u2550\u2550  \u2550\u2550\u2550   \u2502   \u2502  \u2550\u2550\u2550  \u25cb\u25cb\u25cb   \u2502   \u2502  \u2550\u2550\u2550  \u2550\u2550\u2550   \u2502          \u2502\r\n\u2502   \u2502             \u2502   \u2502      swing  \u2502   \u2502             \u2502          \u2502\r\n\u2502   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518          \u2502\r\n\u2502                                                                 \u2502\r\n\u2502   0%                50%              100%                       \u2502\r\n\u2502                  Gait Phase                                     \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,t.jsx)(e.h3,{id:"zero-moment-point-zmp",children:"Zero Moment Point (ZMP)"}),"\n",(0,t.jsx)(e.p,{children:"The ZMP is a fundamental concept in bipedal balance:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'class ZMPController:\r\n    """Zero Moment Point based balance controller"""\r\n    \r\n    def __init__(self, mass: float, com_height: float):\r\n        self.mass = mass\r\n        self.com_height = com_height\r\n        self.g = 9.81\r\n        \r\n    def compute_zmp(self, com_pos: np.ndarray, \r\n                    com_acc: np.ndarray) -> np.ndarray:\r\n        """\r\n        Compute ZMP from center of mass position and acceleration\r\n        \r\n        ZMP = CoM - (h/g) * CoM_acceleration\r\n        """\r\n        zmp = np.zeros(2)\r\n        zmp[0] = com_pos[0] - (self.com_height / self.g) * com_acc[0]\r\n        zmp[1] = com_pos[1] - (self.com_height / self.g) * com_acc[1]\r\n        return zmp\r\n    \r\n    def is_stable(self, zmp: np.ndarray, \r\n                  support_polygon: np.ndarray) -> bool:\r\n        """Check if ZMP is within support polygon"""\r\n        from shapely.geometry import Point, Polygon\r\n        \r\n        point = Point(zmp[0], zmp[1])\r\n        polygon = Polygon(support_polygon)\r\n        \r\n        return polygon.contains(point)\r\n    \r\n    def compute_desired_com_acc(self, \r\n                                 com_pos: np.ndarray,\r\n                                 desired_zmp: np.ndarray) -> np.ndarray:\r\n        """Compute required CoM acceleration to achieve desired ZMP"""\r\n        acc = np.zeros(2)\r\n        acc[0] = (self.g / self.com_height) * (com_pos[0] - desired_zmp[0])\r\n        acc[1] = (self.g / self.com_height) * (com_pos[1] - desired_zmp[1])\r\n        return acc\n'})}),"\n",(0,t.jsx)(e.h3,{id:"linear-inverted-pendulum-model-lipm",children:"Linear Inverted Pendulum Model (LIPM)"}),"\n",(0,t.jsx)(e.p,{children:"A simplified model for walking dynamics:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'class LIPMWalkingController:\r\n    """Walking controller based on Linear Inverted Pendulum Model"""\r\n    \r\n    def __init__(self, com_height: float = 0.8, step_duration: float = 0.4):\r\n        self.h = com_height\r\n        self.g = 9.81\r\n        self.T = step_duration\r\n        \r\n        # Natural frequency\r\n        self.omega = np.sqrt(self.g / self.h)\r\n        \r\n    def plan_footsteps(self, start_pos: np.ndarray, \r\n                       goal_pos: np.ndarray,\r\n                       step_length: float = 0.3,\r\n                       step_width: float = 0.2) -> list:\r\n        """Plan footstep sequence to reach goal"""\r\n        footsteps = []\r\n        \r\n        # Direction to goal\r\n        direction = goal_pos - start_pos\r\n        distance = np.linalg.norm(direction)\r\n        direction = direction / distance\r\n        \r\n        # Generate steps\r\n        current_pos = start_pos.copy()\r\n        is_left = True\r\n        \r\n        while np.linalg.norm(goal_pos - current_pos) > step_length:\r\n            # Lateral offset for alternating feet\r\n            lateral = step_width/2 * (1 if is_left else -1)\r\n            lateral_vec = np.array([-direction[1], direction[0]]) * lateral\r\n            \r\n            # Next foot position\r\n            foot_pos = current_pos + direction * step_length + lateral_vec\r\n            \r\n            footsteps.append({\r\n                \'position\': foot_pos,\r\n                \'is_left\': is_left,\r\n                \'time\': len(footsteps) * self.T\r\n            })\r\n            \r\n            current_pos = foot_pos\r\n            is_left = not is_left\r\n        \r\n        return footsteps\r\n    \r\n    def compute_com_trajectory(self, footsteps: list) -> np.ndarray:\r\n        """Compute CoM trajectory for given footsteps"""\r\n        trajectory = []\r\n        dt = 0.01  # 100 Hz\r\n        \r\n        for i, step in enumerate(footsteps[:-1]):\r\n            next_step = footsteps[i + 1]\r\n            \r\n            # Initial and final CoM positions\r\n            x0 = step[\'position\']\r\n            xf = (step[\'position\'] + next_step[\'position\']) / 2\r\n            \r\n            # Generate trajectory segment\r\n            for t in np.arange(0, self.T, dt):\r\n                # LIPM solution\r\n                x = x0 * np.cosh(self.omega * t) + \\\r\n                    (xf - x0 * np.cosh(self.omega * self.T)) / \\\r\n                    np.sinh(self.omega * self.T) * np.sinh(self.omega * t)\r\n                \r\n                trajectory.append(x)\r\n        \r\n        return np.array(trajectory)\n'})}),"\n",(0,t.jsx)(e.h3,{id:"whole-body-control",children:"Whole-Body Control"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'import osqp\r\nimport scipy.sparse as sparse\r\n\r\nclass WholeBodyController:\r\n    """Whole-body control for humanoid robots"""\r\n    \r\n    def __init__(self, robot_model):\r\n        self.robot = robot_model\r\n        self.nq = robot_model.nq  # Number of joint positions\r\n        self.nv = robot_model.nv  # Number of joint velocities\r\n        \r\n    def compute_control(self, \r\n                        q: np.ndarray,        # Joint positions\r\n                        v: np.ndarray,        # Joint velocities\r\n                        task_targets: dict    # Desired task space targets\r\n                       ) -> np.ndarray:\r\n        """\r\n        Compute joint torques to achieve task-space targets\r\n        Uses QP-based optimization\r\n        """\r\n        # Compute robot dynamics\r\n        M = self.robot.mass_matrix(q)        # Mass matrix\r\n        h = self.robot.nonlinear_effects(q, v)  # Coriolis + gravity\r\n        \r\n        # Task Jacobians\r\n        J_com = self.robot.com_jacobian(q)\r\n        J_left_foot = self.robot.jacobian(q, \'left_foot\')\r\n        J_right_foot = self.robot.jacobian(q, \'right_foot\')\r\n        \r\n        # Build QP problem\r\n        # minimize ||J * qddot - task_acc||^2 + w * ||tau||^2\r\n        # subject to: M * qddot + h = S^T * tau + J_c^T * f\r\n        #             contact constraints\r\n        \r\n        # Stack tasks\r\n        J_tasks = np.vstack([J_com, J_left_foot, J_right_foot])\r\n        task_acc = np.concatenate([\r\n            task_targets[\'com_acc\'],\r\n            task_targets[\'left_foot_acc\'],\r\n            task_targets[\'right_foot_acc\']\r\n        ])\r\n        \r\n        # Solve QP\r\n        qddot, tau, forces = self._solve_qp(\r\n            M, h, J_tasks, task_acc,\r\n            J_left_foot, J_right_foot\r\n        )\r\n        \r\n        return tau\r\n    \r\n    def _solve_qp(self, M, h, J_tasks, task_acc, J_lf, J_rf):\r\n        """Solve the whole-body control QP"""\r\n        # Decision variables: [qddot, tau, f_left, f_right]\r\n        n_qddot = self.nv\r\n        n_tau = self.nv - 6  # Exclude floating base\r\n        n_forces = 12  # 6 per foot\r\n        \r\n        n_vars = n_qddot + n_tau + n_forces\r\n        \r\n        # Cost: minimize task error + regularization\r\n        # ... QP formulation ...\r\n        \r\n        # Placeholder return\r\n        return np.zeros(n_qddot), np.zeros(n_tau), np.zeros(n_forces)\n'})}),"\n",(0,t.jsx)(e.h2,{id:"manipulation",children:"Manipulation"}),"\n",(0,t.jsx)(e.h3,{id:"humanoid-hands",children:"Humanoid Hands"}),"\n",(0,t.jsx)(e.p,{children:"Human-like dexterous manipulation requires sophisticated hand designs:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'class DexterousHand:\r\n    """Controller for dexterous humanoid hand"""\r\n    \r\n    def __init__(self, num_fingers: int = 5, dof_per_finger: int = 4):\r\n        self.num_fingers = num_fingers\r\n        self.dof_per_finger = dof_per_finger\r\n        self.total_dof = num_fingers * dof_per_finger\r\n        \r\n        # Finger names\r\n        self.finger_names = [\'thumb\', \'index\', \'middle\', \'ring\', \'pinky\']\r\n        \r\n    def power_grasp(self, object_size: float) -> np.ndarray:\r\n        """Generate joint angles for power grasp"""\r\n        # Curl all fingers proportional to object size\r\n        curl_amount = np.clip(1.0 - object_size / 0.1, 0.3, 0.9)\r\n        \r\n        joint_angles = np.zeros(self.total_dof)\r\n        for i in range(self.num_fingers):\r\n            base_idx = i * self.dof_per_finger\r\n            # MCP, PIP, DIP joints curl\r\n            joint_angles[base_idx + 1] = curl_amount * 1.4  # MCP\r\n            joint_angles[base_idx + 2] = curl_amount * 1.2  # PIP\r\n            joint_angles[base_idx + 3] = curl_amount * 0.8  # DIP\r\n        \r\n        # Thumb opposition\r\n        joint_angles[0] = 0.8  # Thumb rotation\r\n        \r\n        return joint_angles\r\n    \r\n    def precision_grasp(self, target_width: float) -> np.ndarray:\r\n        """Generate joint angles for precision grasp (pinch)"""\r\n        joint_angles = np.zeros(self.total_dof)\r\n        \r\n        # Position thumb and index finger\r\n        # Thumb\r\n        joint_angles[0] = 1.0   # Opposition\r\n        joint_angles[1] = 0.6   # MCP\r\n        joint_angles[2] = 0.3   # IP\r\n        \r\n        # Index\r\n        joint_angles[4] = 0.0   # Abduction\r\n        joint_angles[5] = 0.5   # MCP\r\n        joint_angles[6] = 0.4   # PIP\r\n        joint_angles[7] = 0.2   # DIP\r\n        \r\n        # Other fingers slightly curled\r\n        for i in range(2, 5):\r\n            base_idx = i * self.dof_per_finger\r\n            joint_angles[base_idx + 1:base_idx + 4] = [0.8, 0.6, 0.4]\r\n        \r\n        return joint_angles\n'})}),"\n",(0,t.jsx)(e.h3,{id:"coordinated-manipulation",children:"Coordinated Manipulation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'class DualArmManipulation:\r\n    """Coordinate dual-arm manipulation for humanoids"""\r\n    \r\n    def __init__(self, left_arm, right_arm):\r\n        self.left = left_arm\r\n        self.right = right_arm\r\n        \r\n    def bimanual_grasp(self, object_pose: np.ndarray, \r\n                       object_width: float) -> tuple:\r\n        """\r\n        Plan bimanual grasp for large objects\r\n        Returns target poses for left and right end-effectors\r\n        """\r\n        # Grasp from sides\r\n        offset = object_width / 2 + 0.05  # 5cm clearance\r\n        \r\n        left_target = object_pose.copy()\r\n        left_target[1] += offset  # Left side\r\n        \r\n        right_target = object_pose.copy()\r\n        right_target[1] -= offset  # Right side\r\n        \r\n        # Orientations facing each other\r\n        left_orientation = Rotation.from_euler(\'z\', -np.pi/2).as_quat()\r\n        right_orientation = Rotation.from_euler(\'z\', np.pi/2).as_quat()\r\n        \r\n        return (\r\n            {\'position\': left_target, \'orientation\': left_orientation},\r\n            {\'position\': right_target, \'orientation\': right_orientation}\r\n        )\r\n    \r\n    def coordinated_motion(self, left_path, right_path):\r\n        """Execute coordinated motion for both arms"""\r\n        assert len(left_path) == len(right_path), "Paths must be same length"\r\n        \r\n        for left_target, right_target in zip(left_path, right_path):\r\n            # IK for both arms\r\n            left_joints = self.left.inverse_kinematics(left_target)\r\n            right_joints = self.right.inverse_kinematics(right_target)\r\n            \r\n            # Execute simultaneously\r\n            self.left.set_joint_positions(left_joints)\r\n            self.right.set_joint_positions(right_joints)\r\n            \r\n            yield left_joints, right_joints\n'})}),"\n",(0,t.jsx)(e.h2,{id:"reinforcement-learning-for-humanoids",children:"Reinforcement Learning for Humanoids"}),"\n",(0,t.jsx)(e.p,{children:"Modern humanoid control increasingly uses RL:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'import gymnasium as gym\r\nfrom stable_baselines3 import PPO\r\n\r\nclass HumanoidWalkingEnv(gym.Env):\r\n    """RL environment for humanoid walking"""\r\n    \r\n    def __init__(self, sim_config):\r\n        super().__init__()\r\n        \r\n        # Initialize simulation\r\n        self.sim = HumanoidSimulator(sim_config)\r\n        \r\n        # Observation: joint positions, velocities, IMU, target\r\n        self.observation_space = gym.spaces.Box(\r\n            low=-np.inf, high=np.inf, \r\n            shape=(self.sim.obs_dim,), \r\n            dtype=np.float32\r\n        )\r\n        \r\n        # Action: target joint positions or torques\r\n        self.action_space = gym.spaces.Box(\r\n            low=-1.0, high=1.0,\r\n            shape=(self.sim.action_dim,),\r\n            dtype=np.float32\r\n        )\r\n        \r\n        self.target_velocity = np.array([1.0, 0.0])  # Walk forward\r\n        \r\n    def reset(self, seed=None):\r\n        super().reset(seed=seed)\r\n        self.sim.reset()\r\n        return self._get_obs(), {}\r\n    \r\n    def step(self, action):\r\n        # Scale action to joint limits\r\n        scaled_action = self._scale_action(action)\r\n        \r\n        # Step simulation\r\n        self.sim.step(scaled_action)\r\n        \r\n        # Compute reward\r\n        reward = self._compute_reward()\r\n        \r\n        # Check termination\r\n        terminated = self._is_fallen()\r\n        truncated = self.sim.time > self.max_episode_time\r\n        \r\n        return self._get_obs(), reward, terminated, truncated, {}\r\n    \r\n    def _compute_reward(self):\r\n        """Reward function for walking"""\r\n        # Forward velocity reward\r\n        velocity = self.sim.get_com_velocity()\r\n        velocity_reward = velocity[0]  # Reward forward motion\r\n        \r\n        # Stability reward\r\n        com_height = self.sim.get_com_position()[2]\r\n        height_reward = -abs(com_height - self.target_height)\r\n        \r\n        # Energy penalty\r\n        energy_penalty = -0.01 * np.sum(self.sim.get_joint_torques()**2)\r\n        \r\n        # Action smoothness\r\n        action_penalty = -0.1 * np.sum(\r\n            (self.current_action - self.prev_action)**2\r\n        )\r\n        \r\n        return velocity_reward + height_reward + energy_penalty + action_penalty\r\n    \r\n    def _is_fallen(self):\r\n        """Check if robot has fallen"""\r\n        com_height = self.sim.get_com_position()[2]\r\n        torso_angle = self.sim.get_torso_orientation()\r\n        \r\n        return com_height < 0.3 or abs(torso_angle) > 1.0\r\n\r\n\r\n# Training\r\nenv = HumanoidWalkingEnv(config)\r\nmodel = PPO(\r\n    "MlpPolicy", \r\n    env,\r\n    learning_rate=3e-4,\r\n    n_steps=2048,\r\n    batch_size=64,\r\n    n_epochs=10,\r\n    gamma=0.99,\r\n    gae_lambda=0.95,\r\n    verbose=1\r\n)\r\n\r\nmodel.learn(total_timesteps=10_000_000)\n'})}),"\n",(0,t.jsx)(e.h2,{id:"future-of-humanoids",children:"Future of Humanoids"}),"\n",(0,t.jsx)(e.h3,{id:"emerging-capabilities",children:"Emerging Capabilities"}),"\n",(0,t.jsxs)(e.table,{children:[(0,t.jsx)(e.thead,{children:(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.th,{children:"Capability"}),(0,t.jsx)(e.th,{children:"Current State"}),(0,t.jsx)(e.th,{children:"Near Future"})]})}),(0,t.jsxs)(e.tbody,{children:[(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:(0,t.jsx)(e.strong,{children:"Walking"})}),(0,t.jsx)(e.td,{children:"Robust on flat ground"}),(0,t.jsx)(e.td,{children:"All terrain, running"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:(0,t.jsx)(e.strong,{children:"Manipulation"})}),(0,t.jsx)(e.td,{children:"Structured tasks"}),(0,t.jsx)(e.td,{children:"General object handling"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:(0,t.jsx)(e.strong,{children:"Autonomy"})}),(0,t.jsx)(e.td,{children:"Teleoperation + scripted"}),(0,t.jsx)(e.td,{children:"VLA-based autonomy"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:(0,t.jsx)(e.strong,{children:"Speed"})}),(0,t.jsx)(e.td,{children:"1-2 m/s"}),(0,t.jsx)(e.td,{children:"Human-like (5+ m/s)"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:(0,t.jsx)(e.strong,{children:"Endurance"})}),(0,t.jsx)(e.td,{children:"1-2 hours"}),(0,t.jsx)(e.td,{children:"Full workday"})]})]})]}),"\n",(0,t.jsx)(e.h3,{id:"challenges-ahead",children:"Challenges Ahead"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Energy efficiency"}),": Current systems are power-hungry"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Robustness"}),": Real-world reliability remains challenging"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"General intelligence"}),": Moving beyond specific tasks"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Cost"}),": Making humanoids economically viable"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Safety"}),": Operating safely around humans"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Humanoid robots"})," are designed to operate in human environments"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Bipedal locomotion"})," requires sophisticated balance and control"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"ZMP and LIPM"})," are fundamental models for walking"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Whole-body control"})," coordinates all DOF for tasks"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Dexterous manipulation"})," enables human-like grasping"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Reinforcement learning"})," is increasingly used for locomotion"]}),"\n",(0,t.jsx)(e.li,{children:"The field is rapidly advancing toward general-purpose humanoids"}),"\n"]}),"\n",(0,t.jsx)(e.hr,{}),"\n","\n",(0,t.jsx)(s.A,{episodeUrl:"/podcast/episodes/ep06-humanoid",episodeNumber:6,duration:"20 min"})]})}function p(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(h,{...n})}):h(n)}},5168(n,e,r){r.d(e,{A:()=>m});r(6540);var i=r(8774);const t="container_dCqE",o="card_xNje",s="icon_xPcq",a="content_EpEg",l="label_oX12",d="title_FgAO",c="duration_fnZY",h="button_ldru";var p=r(4848);function m({episodeUrl:n,episodeNumber:e,duration:r}){return(0,p.jsx)("div",{className:t,children:(0,p.jsxs)("div",{className:o,children:[(0,p.jsx)("div",{className:s,children:(0,p.jsx)("svg",{viewBox:"0 0 24 24",width:"24",height:"24",fill:"currentColor",children:(0,p.jsx)("path",{d:"M12 1c-4.97 0-9 4.03-9 9v7c0 1.66 1.34 3 3 3h3v-8H5v-2c0-3.87 3.13-7 7-7s7 3.13 7 7v2h-4v8h3c1.66 0 3-1.34 3-3v-7c0-4.97-4.03-9-9-9z"})})}),(0,p.jsxs)("div",{className:a,children:[(0,p.jsx)("span",{className:l,children:"Prefer audio?"}),(0,p.jsxs)("span",{className:d,children:["Listen to Episode ",e]}),(0,p.jsxs)("span",{className:c,children:[r," listen"]})]}),(0,p.jsxs)(i.A,{to:n,className:h,children:[(0,p.jsx)("svg",{viewBox:"0 0 24 24",width:"20",height:"20",fill:"currentColor",children:(0,p.jsx)("path",{d:"M8 5v14l11-7z"})}),"Listen Now"]})]})})}},8453(n,e,r){r.d(e,{R:()=>s,x:()=>a});var i=r(6540);const t={},o=i.createContext(t);function s(n){const e=i.useContext(o);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:s(n.components),i.createElement(o.Provider,{value:e},n.children)}}}]);